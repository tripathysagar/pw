"""Various helper function for playwright"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['retry_async', 'BrowserResources', 'PageCreationError', 'BrowserCleanupError', 'setup_browser', 'wait_page',
           'find_ele']

# %% ../nbs/00_core.ipynb 3
from playwright.async_api import  *
from playwright_stealth import stealth_async
from typing import AsyncIterator, List, Tuple, Optional
from contextlib import asynccontextmanager
from dataclasses import dataclass
from fastcore.all import *  # For delegates
from fastcore.utils import *  # For log_args
from fastcore.xtras import * 
import traceback
from datetime import datetime
from functools import partialmethod
from html2text import HTML2Text

# %% ../nbs/00_core.ipynb 4
from functools import wraps
import asyncio

def retry_async(max_retries:int=3, backoff_base:float=1.5):
    """
    Decorator for retrying an asynchronous function upon exception.
    Retries the execution of an async function a specified number of times 
    (`max_retries`) with an exponential backoff delay between attempts (`backoff_base`).
    If all attempts fail, the exception from the last attempt is raised.
    """
    def _retry(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try: return await func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_retries - 1: raise e
                    await asyncio.sleep(backoff_base ** attempt)
        return wrapper
    return _retry

# %% ../nbs/00_core.ipynb 6
@dataclass
class BrowserResources:
    pw_obj: Optional[Playwright] = None
    brow: Optional[Browser] = None
    ctx: Optional[BrowserContext] = None
    pages: List[Page] = None
    is_valid: bool = False # for error handling

class PageCreationError(Exception): pass #Raised when a page fails to be created
class BrowserCleanupError(Exception): pass #Raised when browser resources fail to cleanup

# %% ../nbs/00_core.ipynb 7
@asynccontextmanager
async def setup_browser(*args, n: int = 1, stealth: bool = False, **kwargs) -> AsyncIterator[BrowserResources]:
    """Browser context manager returns n pages and stealth for mode"""
    obj = BrowserResources()
    try:
        if n <= 0:
            raise ValueError(f"Invalid number of pages: {n}")
        
        obj.pw_obj = await async_playwright().start()
        obj.brow = await obj.pw_obj.chromium.launch(*args, **kwargs)
        obj.ctx = await obj.brow.new_context(accept_downloads=True,
                                             storage_state={'cookies': [], 'origins': []}
                                             )
        obj.pages = []
        
        for _ in range(n):
            try:
                pg = await obj.ctx.new_page()
                if stealth: await stealth_async(pg)
                obj.pages.append(pg)
            except Exception as e:
                raise PageCreationError(f"Failed to create page {_}")
                
        obj.is_valid = True
        yield obj
        
    except Exception as e: raise e
        
    finally:
        try:
            if obj.pages:
                for pg in obj.pages:
                    await pg.close()
            if obj.ctx: await obj.ctx.close()
            if obj.brow: await obj.brow.close()
            if obj.pw_obj: await obj.pw_obj.stop()
        except Exception as e:
            raise BrowserCleanupError(f"Failed to cleanup browser resources: {str(e)}")

# %% ../nbs/00_core.ipynb 10
async def _page_ready(page: Page, pause=50, timeout=5000):
    """Wait until main content of page is ready"""
    await page.wait_for_load_state('domcontentloaded')
    await page.wait_for_load_state('networkidle')
    await page.wait_for_timeout(pause)
    try: 
        await page.wait_for_selector('meta', state="attached", timeout=timeout)
    except TimeoutError:
        pass

async def _frames_ready(page: Page, pause=50, timeout=5000):
    """Wait until all visible frames are ready"""
    iframes = await page.query_selector_all('iframe:visible')
    if not iframes: 
        return
    for iframe in iframes:
        await iframe.wait_for_element_state('visible', timeout=timeout)
        await page.wait_for_timeout(pause)
        frame = await iframe.content_frame()
        if frame:
            await frame.wait_for_load_state('domcontentloaded', timeout=timeout)
            await frame.wait_for_load_state('networkidle', timeout=timeout)

async def wait_page(page: Page, pause=50, timeout=5000):
    """
    moneky patching `Page.wait_page`.
    Wait until page and frames are ready to be loaded
    """
    await _page_ready(page, pause, timeout)
    await _frames_ready(page, pause, timeout)

Page.wait_page = partialmethod(wait_page)

# %% ../nbs/00_core.ipynb 12
async def find_ele(page: Page, locator: str)->Optional[List[Locator]]:
    """
    To locate elements on a web page using a given locator and return a list of those elements. 
    Logs error if the  `locator` object is not present and returns `None`.
    """
    try:
        elements = await page.locator(locator).all()
        if elements: return elements
        
        raise ValueError(f"Element not found.")
            
    except Exception as e:
        print(f"Error find : @{page.url}  for {locator} :->  {e}  ")
    return None

Page.find_ele = partialmethod(find_ele)
