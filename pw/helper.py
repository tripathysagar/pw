"""auxilary helper functions"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_helper.ipynb.

# %% auto 0
__all__ = ['h2t', 'IGNORE_EXT', 'print_md', 'table2df', 'h2md', 'domain', 'is_same_resource', 'url2fn']

# %% ../nbs/02_helper.ipynb 2
from urllib.parse import urlparse, parse_qs
import pandas as pd
from io import StringIO
from playwright.async_api import  Page, Locator
from functools import partialmethod
from html2text import HTML2Text
from typing import Union
from IPython.display import Markdown, display

# %% ../nbs/02_helper.ipynb 3
h2t = HTML2Text(bodywidth=20000)
h2t.ignore_links = True
h2t.mark_code = True
h2t.ignore_images = True

# %% ../nbs/02_helper.ipynb 6
def print_md(s : str):
    """
    Given a string display markdown in Notebook
    """
    display(Markdown(s))

# %% ../nbs/02_helper.ipynb 8
async def table2df(table:Locator):
    """Given a html table element it extracts the table obj and convert it to pandas dataframe"""
    try:
        await table.wait_for(state='visible')
        
        table_html = await table.evaluate('element => element.outerHTML')
        
        df = pd.read_html(StringIO(table_html))[0]
        return df
        
    except Exception as e:
        print(f"Error converting table to DataFrame: {e}")
        return None

Locator.table2df = partialmethod(table2df)

# %% ../nbs/02_helper.ipynb 11
async def h2md(ele : Union[Page, Locator]):
    "Convert HTML `h` to markdown using `HTML2Text"

    obj = await ele.inner_html() if isinstance(ele, Locator) else await ele.content() 

    return h2t.handle(str(obj))

Page.h2md = partialmethod(h2md)
Locator.h2md = partialmethod(h2md)

# %% ../nbs/02_helper.ipynb 15
def domain(url:str): 
    """
    Extract domain i.e. netloc given a url
    """
    return urlparse(url).netloc

# %% ../nbs/02_helper.ipynb 17
def is_same_resource(url1: str, url2: str) -> bool:
    """
    Takes in two urls and check if two url have any wuery param
    """
    p1, p2= urlparse(url1), urlparse(url2)
    
    # Parse query and fragment parameters separately
    q1, f1 = parse_qs(p1.query), parse_qs(p1.fragment)
    q2, f2 = parse_qs(p2.query), parse_qs(p2.fragment)
    
    # Combine parameters
    params1 = {**q1, **f1}
    params2 = {**q2, **f2}
    #print(f"{q1=} {q2=} {f1=} {f2=}")
    has_quarter = ('quarter' in params1 or 'quarter' in params2)
    
    base_same = (
        p1.scheme == p2.scheme and
        p1.netloc == p2.netloc and
        p1.path == p2.path
    )
    
    return base_same and not has_quarter

# %% ../nbs/02_helper.ipynb 19
import re

def url2fn(url: str) -> str:
    """takes in a url and return a filename by substituting it with _."""
    # Remove scheme (http:// or https://)
    url = url.split('://')[-1]
    
    fn = re.sub(r'[^a-zA-Z0-9]', '_', url)
    fn = re.sub(r'_+', '_', fn)
    fn = fn.strip('_')
    
    return fn

# %% ../nbs/02_helper.ipynb 21
IGNORE_EXT = ['.css', '.jpg', '.jpeg', '.png', '.gif', '.ico', '.js', '.svg', 'api']

# %% ../nbs/02_helper.ipynb 22
from graphviz import Digraph

def _f():
    dot = Digraph(comment='Crawler Flow')
    dot.attr(rankdir='LR')  # Make the graph horizontal

    # Create subgraph to force alignment
    with dot.subgraph() as s:
        s.attr(rank='same')  # Force nodes to same rank (level)
        s.node('before', 'before_visit\ncallback')
        s.node('visit', 'one_visit')
        s.node('after', 'after_visit\ncallback')

    # Add start/end nodes
    dot.node('start', 'Start', shape='doublecircle')
    dot.node('end', 'End', shape='doublecircle')

    # Add edges
    dot.edge('start', 'before')
    dot.edge('before', 'visit')
    dot.edge('visit', 'after')
    dot.edge('after', 'end')
    dot.edge('after', 'before', constraint='false',  curve_style='curved')
    dot.render("flow", format='png')
_f()
